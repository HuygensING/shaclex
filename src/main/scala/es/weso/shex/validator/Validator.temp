package es.weso.shex.validator
import es.weso.shex._
import es.weso.rdf._
import es.weso.rdf.nodes._
import cats._, data._
import cats.implicits._
import util.matching._
import es.weso.shex.implicits.showShEx._
import es.weso.mytyping._

/**
 * This validator is implemented directly in Scala using cats library
 */
case class Validator(schema: Schema) {


  import es.weso.checking._
  import Validator._

  object MyChecker extends Checker {
    type Config = RDFReader
    type Env = ShapeTyping
    type Err = ViolationError
    type Evidence = (NodeShape, String)
    type Log = List[Evidence]
    implicit val envMonoid: Monoid[Env] = new Monoid[Env] {
      def combine(e1: Env, e2: Env): Env = e1.combineTyping(e2)
      def empty: Env = Typing.empty
    }
    implicit val logCanLog: CanLog[Log] = new CanLog[Log] {
      def log(msg: String): Log = ???
    }
    implicit val logMonoid: Monoid[Log] = new Monoid[Log] {
      def combine(l1: Log, l2: Log): Log = l1 ++ l2
      def empty: Log = List()
    }
    implicit val logShow: Show[Log] = new Show[Log] {
      def show(l: Log): String = l.map { case (ns, msg) => s"${ns}: $msg" }.mkString("\n")
    }
    implicit val typingShow: Show[ShapeTyping] = new Show[ShapeTyping] {
      def show(t: ShapeTyping): String = t.toString
    }
  }
  type ShapeChecker = ShapeExpr => CheckTyping
  type NodeShapeChecker = (RDFNode, Shape) => CheckTyping

  import MyChecker._

  /**
   * Checks that a node satisfies a shape
   */
  type CheckTyping = Check[ShapeTyping]
//  type PropertyChecker = (Attempt, IRI) => CheckTyping
  type NodeChecker = Attempt => RDFNode => CheckTyping


  def runCheck[A: Show](
    c: Check[A],
    rdf: RDFReader): CheckResult[ViolationError, A, Log] = {
    val initial: ShapeTyping = Typing.empty
    val r = run(c)(rdf)(initial)
    CheckResult(r)
  }

}

object Validator {

 def empty = Validator(schema = Schema.empty)

  type ShapeTyping = Typing[RDFNode,ShapeLabel,ViolationError,String]
  type ViolationError = String
 
 type Result[A] =  Xor[NonEmptyList[ViolationError],List[(A,Evidences)]]
  
 def isOK[A](r: Result[A]): Boolean = 
    r.isRight && r.toList.isEmpty == false  
 

}

